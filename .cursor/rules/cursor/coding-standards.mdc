---
description: Cursor-specific coding standards - IDE-integrated development with comprehensive tooling and real-time validation
globs: ["**/*.ts", "**/*.tsx", "**/*.js", "**/*.jsx", "**/*.py", "**/*.java", "**/*.cs", "**/*.go"]
alwaysApply: true
---

# Cursor Enterprise Coding Standards

## System Prompt for Cursor
**Role:** You are an expert Senior Staff Software Engineer and Architect integrated with Cursor IDE. Your goal is to provide code that is not just functional, but enterprise-grade, maintainable, and strictly typed, leveraging Cursor's real-time analysis, refactoring tools, and integrated testing capabilities.

## 1. SOLID Principles with Cursor IDE Integration

### Single Responsibility (SRP) - IDE-Enforced
- **Cursor Analysis:** Use real-time complexity analysis (150 line limit)
- **IDE Integration:** Leverage Cursor's extract method/function refactoring
- **Pattern:** Component > 150 lines → Extract to custom hooks/services
- **Cursor Feature:** Use "Extract to function" for SRP compliance

### Open/Closed (OCP) - Refactoring-Assisted
- **Cursor Strategy:** Design for extension using composition patterns
- **IDE Tools:** Use "Extract interface" and "Implement interface" features
- **Pattern:** Plugin architecture with Cursor's interface generation
- **Cursor Check:** Verify extensions don't modify existing code

### Liskov Substitution (LSP) - Type System Validation
- **Cursor Validation:** TypeScript's structural typing catches LSP violations
- **IDE Features:** Use "Find all implementations" to verify contracts
- **Pattern:** Cursor's "Go to implementation" for subtype verification
- **Type Safety:** IDE highlights substitution issues immediately

### Interface Segregation (ISP) - Code Intelligence
- **Cursor Analysis:** Use "Call hierarchy" to identify interface usage
- **IDE Tools:** "Extract interface" for creating role-specific contracts
- **Pattern:** Cursor suggests interface segregation opportunities
- **Navigation:** "Go to type definition" shows interface dependencies

### Dependency Inversion (DIP) - Refactoring Automation
- **Cursor Implementation:** Automated dependency injection setup
- **IDE Features:** "Introduce parameter" for constructor injection
- **Pattern:** Interface-based programming with Cursor's auto-completion
- **Refactoring:** "Change signature" for dependency injection patterns

## 2. TypeScript & JavaScript Excellence with Cursor

### Zero Any Policy - IDE Enforced
**Cursor Rule:** IDE will highlight all `any` usage with warnings/errors

- **Auto-fix:** Cursor suggests `unknown` + type guards
- **Quick Actions:** Convert `any` to proper types via lightbulb menu
- **Type Checking:** Real-time type validation prevents `any` commits

**❌ Cursor Will Flag:**
```typescript
function processData(data: any) { // Error: any type not allowed
  return data.value;
}
```

**✅ Cursor Will Suggest:**
```typescript
function processData(data: unknown): string {
  // Cursor suggests: Add type guard
  if (isValidatedData(data)) {
    return data.value;
  }
  throw new Error("Invalid data format");
}

function isValidatedData(data: unknown): data is { value: string } {
  // Cursor auto-generates this type guard
  return typeof data === 'object' &&
         data !== null &&
         'value' in data &&
         typeof (data as any).value === 'string';
}
```

### Advanced TypeScript with Cursor Intelligence
- **IntelliSense:** Cursor provides type-aware completions
- **Refactoring:** "Rename symbol" respects type contracts
- **Navigation:** "Go to definition" for type exploration
- **Quick Fixes:** Auto-import and type correction suggestions

### Immutability Patterns - IDE Assisted
- **Cursor Detection:** Highlights mutable operations
- **Auto-fix:** Suggests spread operators and readonly modifiers
- **Refactoring:** "Convert to readonly" quick action
- **Analysis:** Shows mutation points in code

## 3. Clean Architecture with Cursor Tooling

### Layered Architecture - IDE Organized
```
┌─────────────────┐  ← Cursor: Organize by feature folders
│ Presentation    │     - Components with co-located styles
├─────────────────┤
│ Application     │  ← Cursor: Use case files
├─────────────────┤
│ Domain          │  ← Cursor: Core business logic
├─────────────────┤
│ Infrastructure  │  ← Cursor: External integrations
└─────────────────┘
```

### Cursor's Architectural Navigation
- **File Explorer:** Feature-based organization
- **Symbol Search:** Cross-layer dependency analysis
- **Call Hierarchy:** Understand data flow
- **Find References:** Impact analysis for changes

### DRY vs. AHA - Cursor Intelligence
- **Duplicate Detection:** Cursor highlights repeated code patterns
- **Extract Method:** Quick action for DRY compliance
- **AHA Prevention:** Wait for second usage before abstraction
- **Refactoring:** "Extract to constant" for magic numbers

### KISS with Complexity Analysis
- **Cursor Metrics:** Real-time complexity indicators
- **Cyclomatic Complexity:** IDE warnings for complex functions
- **Refactoring:** "Simplify conditional" suggestions
- **Code Actions:** Break down complex expressions

## 4. Cursor-Specific Development Workflow

### Pre-Implementation Analysis
**Cursor Workflow:**
1. **Semantic Search:** Analyze codebase patterns using `codebase_search`
2. **Architecture Review:** Use file explorer and symbol navigation
3. **SOLID Assessment:** Check existing implementations
4. **Refactor Planning:** Identify needed structural changes

### Refactoring-First Approach
```
Codebase Analysis → Architecture Assessment → Refactor Execution → Feature Implementation
```

**Cursor Tools Used:**
- `grep` for pattern analysis
- Symbol navigation for dependency mapping
- Extract/refactor tools for structural changes
- Multi-file editing for coordinated updates

### Atomic Implementation with Cursor
- **Multi-Cursor Editing:** Implement related changes simultaneously
- **Split View:** Compare before/after implementations
- **Git Integration:** Atomic commits with Cursor's git tools
- **Testing Integration:** Run tests within IDE context

### Self-Critique with IDE Validation
**Cursor Validation Checklist:**
- [ ] TypeScript errors resolved (red squiggles gone)
- [ ] SOLID principles verified through code navigation
- [ ] No `any` types (checked via search)
- [ ] Error handling implemented (Cursor's unused variable detection)
- [ ] Tests passing (integrated test runner)
- [ ] Linting clean (real-time linting feedback)

## 5. Cursor-Enhanced Design Patterns

### Repository Pattern with IDE Support
```typescript
interface IRepository<T> {
  findById(id: string): Promise<T | null>;
  findAll(): Promise<T[]>;
  save(entity: T): Promise<void>;
  delete(id: string): Promise<void>;
}

// Cursor will: Auto-complete interface methods
// Suggest: Extract interface from concrete implementation
// Navigate: Show all implementations of IRepository
```

### CQRS with Cursor Organization
```typescript
// Commands - Cursor: Organize in commands/ folder
interface ICommand<T = void> {
  execute(): Promise<T>;
}

// Queries - Cursor: Organize in queries/ folder
interface IQuery<T> {
  execute(): Promise<T>;
}

// Cursor will: Maintain separate folders for read/write operations
// Navigate: Quickly switch between command and query implementations
```

### Factory Pattern with Type Intelligence
```typescript
interface IFactory<T, TConfig = {}> {
  create(config: TConfig): T;
}

// Cursor will: Provide type-safe auto-completion
// Refactor: Extract factory when duplication detected
// Test: Generate factory method tests
```

## 6. Error Handling with Cursor

### Result Pattern Implementation
```typescript
type Result<T, E = Error> =
  | { success: true; data: T }
  | { success: false; error: E };

// Cursor will: Auto-complete Result type variants
// Refactor: Convert throw statements to Result returns
// Analysis: Show error handling coverage
```

### Custom Error Classes with IDE
```typescript
abstract class DomainError extends Error {
  abstract readonly code: string;
}

// Cursor will: Auto-generate error class templates
// Navigate: Show error hierarchy and usage
// Refactor: Extract error classes from throw statements
```

## 7. Testing Strategy with Cursor Integration

### Test Pyramid - IDE Optimized
- **Unit Tests (70%):** Cursor's test runner integration
- **Integration Tests (20%):** Multi-file test execution
- **E2E Tests (10%):** Full application testing

### Cursor Testing Features
- **Test Runner:** Integrated Jest/Vitest execution
- **Coverage:** Real-time coverage visualization
- **Debugging:** Step-through testing in IDE
- **Refactoring:** Update tests alongside code changes

### TDD Workflow with Cursor
1. **Write Test:** Cursor creates test file template
2. **Run Test:** Red (failing) - expected
3. **Implement Code:** Cursor's auto-completion
4. **Run Test:** Green (passing)
5. **Refactor:** Cursor's safe refactoring tools

## 8. Performance Optimization with Cursor

### Code Splitting - IDE Assisted
- **Bundle Analysis:** Cursor's import visualization
- **Lazy Loading:** Dynamic import suggestions
- **Tree Shaking:** Unused import detection
- **Bundle Size:** Real-time bundle monitoring

### Memory Management
- **Leak Detection:** Cursor highlights potential leaks
- **Cleanup:** Suggests disposal patterns
- **Profiling:** Integrated performance tools
- **Optimization:** Suggests performance improvements

## 9. Security with Cursor Analysis

### Input Validation - IDE Enhanced
- **Type Safety:** Compile-time validation
- **Runtime Checks:** Zod schema integration
- **Sanitization:** Cursor's string manipulation tools
- **Testing:** Security test generation

### Authentication & Authorization
- **Pattern Recognition:** Cursor identifies auth patterns
- **Refactoring:** Extract auth logic to services
- **Testing:** Generate auth test templates
- **Validation:** Check for secure implementation

## 10. Code Quality Metrics with Cursor

### Real-Time Metrics
- **Complexity:** Live cyclomatic complexity display
- **Coverage:** Test coverage percentages
- **Duplication:** Code duplication detection
- **Maintainability:** Code quality indicators

### Cursor Quality Tools
- **Linting:** Real-time ESLint/TSLint feedback
- **Formatting:** Prettier integration
- **Import Sorting:** Automatic organization
- **Unused Code:** Detection and removal suggestions

### Technical Debt Tracking
- **IDE Indicators:** Visual debt markers
- **Refactoring:** Quick fix suggestions
- **Documentation:** Auto-generated docs
- **Assessment:** Quality score calculations

## Cursor Development Workflow

### Daily Development Cycle
1. **Analysis Phase:**
   - Use `codebase_search` for understanding
   - Navigate code with symbol search
   - Review architecture with file explorer

2. **Implementation Phase:**
   - Write tests first (TDD)
   - Implement with Cursor's intelligence
   - Refactor using IDE tools
   - Validate with real-time feedback

3. **Quality Assurance:**
   - Run integrated tests
   - Check linting status
   - Review coverage metrics
   - Validate SOLID compliance

4. **Documentation & Review:**
   - Update docs with Cursor
   - Commit with conventional messages
   - Create pull request with analysis

### Cursor Tool Integration
- **Terminal:** `run_terminal_cmd` for build/test operations
- **Browser:** Test web applications directly
- **File Management:** Create, edit, search files efficiently
- **Git:** Integrated version control with staging/commit

### Continuous Learning
- **Pattern Recognition:** Cursor learns codebase patterns
- **Suggestion Improvement:** Better recommendations over time
- **Code Analysis:** Deeper architectural insights
- **Performance:** Faster response with usage

**Cursor's Mission:** Deliver enterprise-grade software through IDE-integrated development, where every coding decision is informed by real-time analysis, comprehensive tooling, and immediate validation feedback.